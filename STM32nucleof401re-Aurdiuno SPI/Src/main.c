/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
//SPI2

int main(void) {
	//SPI Clock enable from RCC (Pheripheral clock enable register RCC_APB2)
	uint32_t *pspi2clockenable = 0x40023840;
	*pspi2clockenable |= (1 << 14);
	//RCC Pheripheral clock enable (RCC_AHB1ENR)
	uint32_t *pgpioclockenable = 0x40023830;
	//Set GPIOB and GPIOC bits in (RCC_AHB1ENR)
	*pgpioclockenable |= (1 << 1) | (1 << 2);
	//GPIOB PORT MODE REGISTER
	uint32_t *pgpiobportmoderegister = 0x40020400;
	//GPIOC PORT MODE REGISTER
	uint32_t *pgpiocportmoderegister = 0x40020800;

	//SPI2 PINS - Alternate function for SPI
	//PB10 -SCK
	//PC2 -MISO
	//PC3 - MOSI
	//Alternate function(PB10) Choose Alternate value for bits
	*pgpiobportmoderegister |= (1 << 21);
	*pgpiobportmoderegister &= ~(1 << 20);
	//Alternate function(PC2 nad PC3)
	*pgpiocportmoderegister |= (1 << 5) | (1 << 7);
	*pgpiocportmoderegister &= ~((1 << 6) | (1 << 4));

	//GPIO alternate function low register (GPIOx_AFRH) SPI(0101 on corresponding bits)
	uint32_t *pgpiobalterlow = 0x40020424;
	//alternate function low AF5-0101(22 and 20 bits)
	*pgpiobalterlow |= (1 << 10) | (1 << 8);
	*pgpiobalterlow &= ~((1 << 11) | (1 << 9));
        //GPIO alternate function low register (GPIOx_AFRL)  SPI(0101 on corresponding bits)
	uint32_t *pgpiocalterlow = 0x40020820;
	//alternate function low PC2 and PC3(0101)
	*pgpiocalterlow |= (1 << 10) | (1 << 8) | (1 << 14) | (1 << 12);
	*pgpiocalterlow &= ~((1 << 11) | (1 << 9) | (1 << 15) | (1 << 13));
	//SPI2 control register
	uint16_t *pspicontrolreg1 = 0x40003800;
	*pspicontrolreg1 &= ~((1 << 0) | (1 << 1)); //clock polarity and phase 00(low)
	*pspicontrolreg1 |= (1 << 2); //Master mode
	*pspicontrolreg1 |= ((1 << 4) | (1 << 3)); //fosc/16
	*pspicontrolreg1 &= ~(1 << 5);
	*pspicontrolreg1 &= ~(1 << 7);//Transmit LSB first
	*pspicontrolreg1 |= (1 << 8) | (1 << 9); //Enable Software slave management
	*pspicontrolreg1 &= ~(1 << 10);
	*pspicontrolreg1 &= ~(1 << 11);

	//SPI Control register2 (SPI_CR2)
	uint16_t *pspicontrolreg2 = 0x40003804;
	//*pspicontrolreg2 |= (1 << 2);

	*pspicontrolreg1 |= (1 << 6); //Enable SPI

	//SPI2 Status register (SPI_SR)
	uint16_t *pspistatusreg = 0x40003808;
    //SPI2 Data register
	uint16_t *pspidatareg = 0x4000380C;
	//Pheripheral clock enable for PORT B

	//Data to be written/Transmitted on SPDR
	uint8_t dataarr = 0x02;
	//Check transmit buffer is empty
	uint8_t val = *pspistatusreg & (1 << 1);
	while (val == 0) {

	}
	;
	//If transmit buffer is empty, write data in to SPI data register which then moves to shift register
	*pspidatareg = dataarr;

	//After writing SPDR ,check transmitter flag and busy flag to one if you have multiple data
	uint8_t val1 = *pspistatusreg & (1 << 1);
	while (!(val1)) {
	}
	;
	while ((*pspistatusreg & (1 << 7))) {
	}
	;
	uint16_t dummy3 = *pspidatareg;
	dummy3 = *pspistatusreg;

	//Reciever
	while ((*pspistatusreg & (1 << 0))) {
	}
	;

	uint8_t datarec = *pspidatareg;

	//uint8_t dummy = (uint8_t) *pspidatareg;
	//uint8_t dummy1 = *pspistatusreg;
	return 0;
}

